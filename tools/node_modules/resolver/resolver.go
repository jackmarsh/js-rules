package resolver

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"sort"
	"strings"
	"sync"
	"text/template"
	"time"

	"golang.org/x/sync/errgroup"
	"github.com/Masterminds/semver/v3"
)

// PackageJSON represents the structure of package.json
type PackageJSON struct {
	Name                 string            `json:"name"`
	Version              string            `json:"version"`
	Dependencies         map[string]string `json:"dependencies"`
	OptionalDependencies map[string]string `json:"optionalDependencies"`
}

// NodeModule represents a node_module build rule
type NodeModule struct {
	Name        string
	Scope       string
	Module      string
	Version     string
	Visibility  []string
	Deps        []string
	Hashes      []string
	Binary      bool
	ResolvedURL string
}

// Resolver handles dependency resolution.
type Resolver struct {
	modules         map[string]*NodeModule // Key: "name@version"
	depReqToNameVer map[string]string      // Key: "dep@req", Value: name@version
	buildTargetSet  map[string]struct{}      // Key: "target_name",
	
	nameMap   map[string]string
	registryURL string
	timeout     time.Duration
	mu          sync.Mutex
}

// NewResolver instantiates and returns a new Resolver.
func NewResolver(registryURL string) *Resolver {
	return &Resolver{
		modules: make(map[string]*NodeModule),
		depReqToNameVer: make(map[string]string),
		buildTargetSet: make(map[string]struct{}),
		registryURL: registryURL,
	}
}

// WithTimeout set individual dep resolution timeout.
func (r *Resolver) WithTimeout(timeout int) *Resolver {
	r.timeout = time.Duration(timeout) * time.Second
	return r
}

// ResolveDependency resolves a single dependency.
func (r *Resolver) ResolveDependency(ctx context.Context, name, versionReq string) error {
	errGroup, ctx := errgroup.WithContext(ctx)
	errGroup.Go(func() error {
		return r.resolve(ctx, name, versionReq)
	})
	if err := errGroup.Wait(); err != nil {
		return err
	}
	return nil
}

func (r *Resolver) resolve(ctx context.Context, name, versionReq string) error {
	ctx, cancel := context.WithTimeout(ctx, r.timeout)
	defer cancel()

	version, err := r.getLatestSatisfyingVersion(ctx, name, versionReq)
	if err != nil {
		return fmt.Errorf("failed to resolve %s@%s: %v", name, versionReq, err)
	}
	key := fmt.Sprintf("%s@%s", name, version)
	depKey := fmt.Sprintf("%s@%s", name, versionReq)
	r.mu.Lock()
	if _, ok := r.depReqToNameVer[depKey]; !ok {
		r.depReqToNameVer[depKey] = key
	}
	if _, ok := r.modules[key]; ok {
		r.mu.Unlock()
		fmt.Printf("Module %s already processed. Skipping.\n\n", key)
		return nil
	}
	r.mu.Unlock()

	pkg, err := r.fetchPackageJSON(ctx, name, version)
	if err != nil {
		return fmt.Errorf("failed to fetch package.json for %s@%s: %v", name, version, err)
	}

	
	scope, moduleName := parseScopeAndModule(name)
	var url string
	if scope != "" {
		url = fmt.Sprintf("%s/%s/%s/-/%s-%s.tgz", r.registryURL, scope, moduleName, moduleName, version)
	} else {
		url = fmt.Sprintf("%s/%s/-/%s-%s.tgz", r.registryURL, moduleName, moduleName, version)
	}

	// We need to ensure that the node_module has a unique target name.
	r.mu.Lock()
	uniqueName := sanitizeName(name)
	if _, ok := r.buildTargetSet[uniqueName]; ok {
		uniqueName = fmt.Sprintf("%s.%s", uniqueName, version)
	}
	nodeModule := &NodeModule{
		Name:        uniqueName,
		Scope:       scope,
		Module:      moduleName,
		Version:     version,
		Visibility:  []string{"PUBLIC"},
		Deps:        []string{},
		Hashes:      []string{},
		Binary:      false,
		ResolvedURL: url,
	}
	if _, ok := r.modules[key]; !ok {
		// In-case of race condition. Do not overwrite.
		r.modules[key] = nodeModule
	}
	if _, ok := r.buildTargetSet[nodeModule.Name]; !ok {
		r.buildTargetSet[nodeModule.Name] = struct{}{}
	}
	r.mu.Unlock()

	allDeps := make(map[string]string)
	for dep, req := range pkg.Dependencies {
		allDeps[dep] = req
	}
	for dep, req := range pkg.OptionalDependencies {
		allDeps[dep] = req
	}

	errGroup, ctx := errgroup.WithContext(ctx)
	for depName, depReq := range allDeps {
		fmt.Printf("Resolving %s dependency %s@%s\n", key, depName, depReq)
		depName := depName
		depReq := depReq
		errGroup.Go(func() error {
			return r.resolve(ctx, depName, depReq)
		})
	}
	if err := errGroup.Wait(); err != nil {
		return err
	}
	for depName, depReq := range allDeps {
		r.mu.Lock()
		depKey := fmt.Sprintf("%s@%s", depName, depReq)
		nameVer, ok := r.depReqToNameVer[depKey]
		r.mu.Unlock()
		if !ok {
			return fmt.Errorf("missing %s dependency resolution for %s", nodeModule.Name, depKey)
		}
		r.mu.Lock()
		module, ok := r.modules[nameVer]
		r.mu.Unlock()
		if !ok {
			return fmt.Errorf("missing %s dependency resolution for %s", nodeModule.Name, depKey)
		}
		nodeModule.Deps = append(nodeModule.Deps, module.Name)
	}
	
	sort.Slice(nodeModule.Deps, func(i, j int) bool {
		return nodeModule.Deps[i] < nodeModule.Deps[j]
	})	
	return nil
}

func (r *Resolver) getLatestSatisfyingVersion(ctx context.Context, name, versionReq string) (string, error) {
	encodedName := encodePackageName(name)
	url := fmt.Sprintf("%s/%s", r.registryURL, encodedName)

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return "", fmt.Errorf("failed to create HTTP request: %v", err)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return "", fmt.Errorf("HTTP GET failed: %v", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("HTTP GET returned status %d", resp.StatusCode)
	}
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to read response body: %v", err)
	}
	var metadata struct {
		Versions map[string]PackageJSON `json:"versions"`
	}
	err = json.Unmarshal(body, &metadata)
	if err != nil {
		return "", fmt.Errorf("JSON unmarshal failed: %v", err)
	}
	constraint, err := semver.NewConstraint(versionReq)
	if err != nil {
		return "", fmt.Errorf("invalid semver range %s: %v", versionReq, err)
	}
	var satisfyingVersions []*semver.Version
	for ver := range metadata.Versions {
		parsedVer, err := semver.NewVersion(ver)
		if err != nil {
			continue
		}
		if constraint.Check(parsedVer) {
			satisfyingVersions = append(satisfyingVersions, parsedVer)
		}
	}

	if len(satisfyingVersions) == 0 {
		return "", fmt.Errorf("no versions found for %s satisfying %s", name, versionReq)
	}
	sort.Slice(satisfyingVersions, func(i, j int) bool {
		return satisfyingVersions[i].GreaterThan(satisfyingVersions[j])
	})
	return satisfyingVersions[0].String(), nil
}

// fetchPackageJSON retrieves the package.json for a given module and version from the npm registry
func (r *Resolver) fetchPackageJSON(ctx context.Context, name, version string) (*PackageJSON, error) {
	encodedName := encodePackageName(name)
	url := fmt.Sprintf("%s/%s/%s", r.registryURL, encodedName, version)
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create HTTP request: %v", err)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("HTTP GET failed: %v", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("HTTP GET returned status %d", resp.StatusCode)
	}
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %v", err)
	}
	var pkg *PackageJSON
	err = json.Unmarshal(body, &pkg)
	if err != nil {
		return nil, fmt.Errorf("JSON unmarshal failed: %v", err)
	}

	return pkg, nil
}

// sanitizeName replaces '/' with '_' to make the name suitable for build rules
func sanitizeName(name string) string {
	return strings.ReplaceAll(name, "/", "_")
}

// parseScopeAndModule parses the package name to extract scope and module name
func parseScopeAndModule(name string) (string, string) {
	if strings.HasPrefix(name, "@") {
		parts := strings.SplitN(name, "/", 2)
		if len(parts) == 2 {
			return parts[0], parts[1]
		}
		return "", strings.ReplaceAll(name, "/", "_")
	}
	return "", strings.ReplaceAll(name, "/", "_")
}

// encodePackageName encodes the package name for URL purposes
func encodePackageName(name string) string {
	if strings.HasPrefix(name, "@") {
		return strings.ReplaceAll(name, "/", "%2F")
	}
	return name
}

var nodeModuleTemplate = `
node_module(
    name = "{{.Name}}"{{if .Module}},
    module = "{{.Module}}"{{end}}{{if .Scope}},
    scope = "{{.Scope}}"{{end}},
    version = "{{.Version}}"{{if .Visibility}},
    visibility = [
        {{- range $index, $element := .Visibility }}
        "{{ $element }}",
        {{- end }}
    ]{{end}}{{if .Deps}},
    deps = [
        {{- range $index, $element := .Deps }}
        ":{{ $element }}",
        {{- end }}
    ]{{end}}{{if .Hashes}},
    hashes = [
        {{- range $index, $element := .Hashes }}
        "{{ $element }}",
        {{- end }}
    ]{{end}}{{if .Binary}},
    binary = True{{end}},
)
`

var parsedNodeModuleTemplate *template.Template

func init() {
    var err error
    parsedNodeModuleTemplate, err = template.New("node_module").Parse(nodeModuleTemplate)
    if err != nil {
        panic(fmt.Sprintf("Failed to parse node_module template: %v", err))
    }
}

// GenerateBUILD generates the build rules and writes them to the specified file
func (r *Resolver) GenerateBUILD(outputFile string) error {
    file, err := os.Create(outputFile)
    if err != nil {
        return fmt.Errorf("failed to create output file: %v", err)
    }
    defer file.Close()

    // Collect and sort modules for consistent output
    r.mu.Lock()
    keys := make([]string, 0, len(r.modules))
    for key := range r.modules {
        keys = append(keys, key)
    }
    sort.Strings(keys)
    r.mu.Unlock()

    // Iterate over each module and write the build rule
    for _, key := range keys {
        r.mu.Lock()
        module := r.modules[key]
        r.mu.Unlock()

        if module == nil {
            continue
        }

        // Prepare NodeModuleData for the template
        data := NodeModule{
            Name:        module.Name,
            Module:      module.Module,
            Scope:       module.Scope,
            Version:     module.Version,
            Visibility:  module.Visibility,
            Deps:        module.Deps,
            Hashes:      module.Hashes,
            Binary:      module.Binary,
        }

        // Execute the template with the data
        err := parsedNodeModuleTemplate.Execute(file, data)
        if err != nil {
            return fmt.Errorf("failed to execute template for %s: %v", key, err)
        }
    }

    return nil
}
